{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the JDA-Wiki \u00b6 Welcome to the JDA-Wiki. Please not that this is not the official wiki of JDA. You can find this one here . Downloads \u00b6 Version Latest Dev build: Latest Release: Pages \u00b6 Setup \u00b6 IntelliJ Eclipse Netbeans Using JDA \u00b6 Getting started RestActions Asynchronous Blocking (Synchronous) Cancelable Planning GatewayIntents Copyright \u00b6 All depicted images are the property of their respective owners, unless mentioned otherwise. I do not claim to have the copyright of the images depicted and only use them for the purpose of demonstration.","title":"Welcome"},{"location":"#welcome-to-the-jda-wiki","text":"Welcome to the JDA-Wiki. Please not that this is not the official wiki of JDA. You can find this one here .","title":"Welcome to the JDA-Wiki"},{"location":"#downloads","text":"Version Latest Dev build: Latest Release:","title":"Downloads"},{"location":"#pages","text":"","title":"Pages"},{"location":"#setup","text":"IntelliJ Eclipse Netbeans","title":"Setup"},{"location":"#using-jda","text":"Getting started RestActions Asynchronous Blocking (Synchronous) Cancelable Planning GatewayIntents","title":"Using JDA"},{"location":"#copyright","text":"All depicted images are the property of their respective owners, unless mentioned otherwise. I do not claim to have the copyright of the images depicted and only use them for the purpose of demonstration.","title":"Copyright"},{"location":"setup/","text":"Setup \u00b6 You can setup JDA in multiple ways and with multiple IDEs. Below can you find some of the most common ones used. IntelliJ Eclipse Netbeans","title":"Setup"},{"location":"setup/#setup","text":"You can setup JDA in multiple ways and with multiple IDEs. Below can you find some of the most common ones used. IntelliJ Eclipse Netbeans","title":"Setup"},{"location":"setup/eclipse/","text":"Eclipse setup \u00b6 Eclipse (Eclipse IDE) is an IDE for Java development build by the Eclipse foundation . You can download it here . Notes Replace JDA_VERSION_HERE with the listed version here . There are multiple ways to setup Eclipse. Select the one that fits best for your needs. Setup Gradle (recommendet) Setup Maven Setup from Jar Setup Gradle \u00b6 Note If you have Eclipse IDE for Java Developers installed, skip to step 2. Otherwise, you need to install the Buildship Gradle Integration plugin first. Install the Buildship Gradle Integration plugin. Open up Eclipse and go to the Marketplace (Located under the \"Help\" tab). Search for \"Gradle\" and install Buildship Gradle Integration ( Plugin page ) After the plugin was installed, restart Eclipse. Right-click within Package/Project Explorer and Select New -> Other... In the Gradle folder, select \"Gradle Project\". Write a name for your project and click on \"Finish\". Your setup should look similar to this: Delete the classes located under src/main/java and src/test/java Open the build.gradle and replace its content with the following code: plugins { id'application' id'com.github.johnrengelman.shadow' version '4.0.4' } mainClassName = 'com.example.jda.Bot' version '1.0' def jdaVersion = 'JDA_VERSION_HERE' sourceCompatibility = targetCompatibility = 1.8 repositories { jcenter() } dependencies { compile \"net.dv8tion:JDA:$jdaVersion\" } compileJava.options.encoding = 'UTF-8' Create the package of your bot in src/main/java . For example: me.name.bot Create your first Class. For example: Bot.java Configure the mainClassName in your build.gradle to point towards your Class ( me.name.bot.Bot in our case) Save everything, right-click your project and select Gradle -> Refresh All All required dependencies should now be downloaded. To build a jar, run gradlew shadowJar in a terminal at the root folder of your project. Setup Maven \u00b6 Important Requires the Maven-Plugin and local Maven installation! Create a new Maven Project ( File -> New -> Other -> Maven -> Maven Project ) Open the pom.xml and add the following part right after </description> to make the project support UTF-8: <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <maven.compiler.source> 1.8 </maven.compiler.source> <maven.compiler.target> 1.8 </maven.compiler.target> </properties> Add the jcenter repository for JDA to your pom.xml (Only add the part in <repository></repository> if you alread have <repositories></repositories> ): <repositories> <repository> <snapshots> <enabled> false </enabled> </snapshots> <id> jcenter </id> <name> jcenter-bintray </name> <url> http://jcenter.bintray.com </url> </repository> </repositories> Add JDA as dependency (Only add the part in <dependency></dependency> if you already have <dependencies></dependencies> ): <dependencies> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> JDA_VERSION_HERE </version> <type> jar </type> <scope> compile </scope> </dependency> </dependencies> Add the following code to setup shading for your project (Note that this will force the compiler to use Java 8!). <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-compiler-plugin </artifactId> <version> 3.5.1 </version> <configuration> <source> 1.8 </source> <target> 1.8 </target> </configuration> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-shade-plugin </artifactId> <version> 2.4.3 </version> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <artifactSet> <excludes> <exclude> example </exclude> <!-- You may add jars to exclude from shading --> </excludes> </artifactSet> </configuration> </execution> </executions> </plugin> </plugins> </build> Setup from jar \u00b6 Downloaded the latest release (Bintray) of JDA (with dependencies): GitHub release (recommendet) Jenkins builds Create a new Java Project. Fill out the Project name and set it to use Java 8 or higher. Right-click the Project and select \"Properties\". Click on \"Java Build Path\", then click on the \"Libraries\" tab and finally on \"Add External JARs...\" Add the downloaded JDA jarfile and expand its properties. You can skip to step 11 if you don't want Javadoc and Source annotations (Not recommendet). Click on \"Source Attachment\" followed by \"Edit...\" and mark \"External Locations\". Finally click on \"External File\". Add the JDA-JDA_VERSION_HERE-sources.jar and click OK. Click on \"Javadoc Location\", followed by \"Edit...\" and then mark \"Javadoc in archive\" before clicking on \"Browse\". Add the JDA-JDA_VERSION_HERE-javadoc.jar and click OK. You're done!","title":"Eclipse"},{"location":"setup/eclipse/#eclipse-setup","text":"Eclipse (Eclipse IDE) is an IDE for Java development build by the Eclipse foundation . You can download it here . Notes Replace JDA_VERSION_HERE with the listed version here . There are multiple ways to setup Eclipse. Select the one that fits best for your needs. Setup Gradle (recommendet) Setup Maven Setup from Jar","title":"Eclipse setup"},{"location":"setup/eclipse/#setup-gradle","text":"Note If you have Eclipse IDE for Java Developers installed, skip to step 2. Otherwise, you need to install the Buildship Gradle Integration plugin first. Install the Buildship Gradle Integration plugin. Open up Eclipse and go to the Marketplace (Located under the \"Help\" tab). Search for \"Gradle\" and install Buildship Gradle Integration ( Plugin page ) After the plugin was installed, restart Eclipse. Right-click within Package/Project Explorer and Select New -> Other... In the Gradle folder, select \"Gradle Project\". Write a name for your project and click on \"Finish\". Your setup should look similar to this: Delete the classes located under src/main/java and src/test/java Open the build.gradle and replace its content with the following code: plugins { id'application' id'com.github.johnrengelman.shadow' version '4.0.4' } mainClassName = 'com.example.jda.Bot' version '1.0' def jdaVersion = 'JDA_VERSION_HERE' sourceCompatibility = targetCompatibility = 1.8 repositories { jcenter() } dependencies { compile \"net.dv8tion:JDA:$jdaVersion\" } compileJava.options.encoding = 'UTF-8' Create the package of your bot in src/main/java . For example: me.name.bot Create your first Class. For example: Bot.java Configure the mainClassName in your build.gradle to point towards your Class ( me.name.bot.Bot in our case) Save everything, right-click your project and select Gradle -> Refresh All All required dependencies should now be downloaded. To build a jar, run gradlew shadowJar in a terminal at the root folder of your project.","title":"Setup Gradle"},{"location":"setup/eclipse/#setup-maven","text":"Important Requires the Maven-Plugin and local Maven installation! Create a new Maven Project ( File -> New -> Other -> Maven -> Maven Project ) Open the pom.xml and add the following part right after </description> to make the project support UTF-8: <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <maven.compiler.source> 1.8 </maven.compiler.source> <maven.compiler.target> 1.8 </maven.compiler.target> </properties> Add the jcenter repository for JDA to your pom.xml (Only add the part in <repository></repository> if you alread have <repositories></repositories> ): <repositories> <repository> <snapshots> <enabled> false </enabled> </snapshots> <id> jcenter </id> <name> jcenter-bintray </name> <url> http://jcenter.bintray.com </url> </repository> </repositories> Add JDA as dependency (Only add the part in <dependency></dependency> if you already have <dependencies></dependencies> ): <dependencies> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> JDA_VERSION_HERE </version> <type> jar </type> <scope> compile </scope> </dependency> </dependencies> Add the following code to setup shading for your project (Note that this will force the compiler to use Java 8!). <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-compiler-plugin </artifactId> <version> 3.5.1 </version> <configuration> <source> 1.8 </source> <target> 1.8 </target> </configuration> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-shade-plugin </artifactId> <version> 2.4.3 </version> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <artifactSet> <excludes> <exclude> example </exclude> <!-- You may add jars to exclude from shading --> </excludes> </artifactSet> </configuration> </execution> </executions> </plugin> </plugins> </build>","title":"Setup Maven"},{"location":"setup/eclipse/#setup-from-jar","text":"Downloaded the latest release (Bintray) of JDA (with dependencies): GitHub release (recommendet) Jenkins builds Create a new Java Project. Fill out the Project name and set it to use Java 8 or higher. Right-click the Project and select \"Properties\". Click on \"Java Build Path\", then click on the \"Libraries\" tab and finally on \"Add External JARs...\" Add the downloaded JDA jarfile and expand its properties. You can skip to step 11 if you don't want Javadoc and Source annotations (Not recommendet). Click on \"Source Attachment\" followed by \"Edit...\" and mark \"External Locations\". Finally click on \"External File\". Add the JDA-JDA_VERSION_HERE-sources.jar and click OK. Click on \"Javadoc Location\", followed by \"Edit...\" and then mark \"Javadoc in archive\" before clicking on \"Browse\". Add the JDA-JDA_VERSION_HERE-javadoc.jar and click OK. You're done!","title":"Setup from jar"},{"location":"setup/intellij/","text":"IntelliJ IDEA setup \u00b6 IntelliJ IDEA is an IDE for Java development made by Jetbrains . You can download it here . Notes Replace JDA_VERSION_HERE with the listed version here . IntelliJ v2019 \u00b6 This is the setup when using IntelliJ v2019.x.x For setup with older versions see here Navigate to \"New Project\" (i.e. File -> New -> Project... ) Select Gradle on the left side and check \"Java\" under \"Additional Libraries and Frameworks\" Give your project a name. You can optionally also edit the location where it should be saved in. Make sure to click on \"Artifact Coordinates\" to expand it. There set a path for your groupId and optionally alter the version. Click on \"Finish\" to create the project. You may get asked if you want to import dependencies. You can choose there to enable auto-import, but this can also be done in your settings. If you use a different Runner for your project can you also change this in the settings. Let IntelliJ index the project. Open the build.gradle file and populate it with the following content. plugins { id'application' id'com.github.johnrengelman.shadow' version '4.0.4' } mainClassName = 'com.example.jda.Bot' version '1.0' def jdaVersion = 'JDA_VERSION_HERE' sourceCompatibility = targetCompatibility = 1.8 repositories { jcenter() } dependencies { compile \"net.dv8tion:JDA:$jdaVersion\" } compileJava.options.encoding = 'UTF-8' If IntelliJ didn't already do it, create a directory called src/main/java Create the package of your bot. For example: me.name.bot Create your first Class. For example: Bot.java Configure the mainClassName in your build.gradle to point towards your class ( me.name.bot.Bot in our case). Setup your Bot. Example: To build your jar, use the gradlew shadowJar command. You can also run your project with the run gradle task. Continue to Getting started. Older IntelliJ version \u00b6 This is for versions before v2019 Open the project view. Click on \"Create New Projecr\" to start a new project. Select Gradle on the left side and check \"Java\" under \"Additional Libraries and Frameworks\". Click \"Next\" and fill out GroupId with your path (i.e. me.name ) and ArtifactId with the name of your bot/application (i.e. Bot ). Make sure to check \"Use auto-import\", click \"Next\" and then \"Finish\". You can now continue with step 5 for the newer version of IntelliJ","title":"IntelliJ"},{"location":"setup/intellij/#intellij-idea-setup","text":"IntelliJ IDEA is an IDE for Java development made by Jetbrains . You can download it here . Notes Replace JDA_VERSION_HERE with the listed version here .","title":"IntelliJ IDEA setup"},{"location":"setup/intellij/#intellij-v2019","text":"This is the setup when using IntelliJ v2019.x.x For setup with older versions see here Navigate to \"New Project\" (i.e. File -> New -> Project... ) Select Gradle on the left side and check \"Java\" under \"Additional Libraries and Frameworks\" Give your project a name. You can optionally also edit the location where it should be saved in. Make sure to click on \"Artifact Coordinates\" to expand it. There set a path for your groupId and optionally alter the version. Click on \"Finish\" to create the project. You may get asked if you want to import dependencies. You can choose there to enable auto-import, but this can also be done in your settings. If you use a different Runner for your project can you also change this in the settings. Let IntelliJ index the project. Open the build.gradle file and populate it with the following content. plugins { id'application' id'com.github.johnrengelman.shadow' version '4.0.4' } mainClassName = 'com.example.jda.Bot' version '1.0' def jdaVersion = 'JDA_VERSION_HERE' sourceCompatibility = targetCompatibility = 1.8 repositories { jcenter() } dependencies { compile \"net.dv8tion:JDA:$jdaVersion\" } compileJava.options.encoding = 'UTF-8' If IntelliJ didn't already do it, create a directory called src/main/java Create the package of your bot. For example: me.name.bot Create your first Class. For example: Bot.java Configure the mainClassName in your build.gradle to point towards your class ( me.name.bot.Bot in our case). Setup your Bot. Example: To build your jar, use the gradlew shadowJar command. You can also run your project with the run gradle task. Continue to Getting started.","title":"IntelliJ v2019"},{"location":"setup/intellij/#older-intellij-version","text":"This is for versions before v2019 Open the project view. Click on \"Create New Projecr\" to start a new project. Select Gradle on the left side and check \"Java\" under \"Additional Libraries and Frameworks\". Click \"Next\" and fill out GroupId with your path (i.e. me.name ) and ArtifactId with the name of your bot/application (i.e. Bot ). Make sure to check \"Use auto-import\", click \"Next\" and then \"Finish\". You can now continue with step 5 for the newer version of IntelliJ","title":"Older IntelliJ version"},{"location":"setup/netbeans/","text":"","title":"Netbeans"},{"location":"usage/","text":"Getting started \u00b6","title":"Getting started"},{"location":"usage/#getting-started","text":"","title":"Getting started"},{"location":"usage/gatewayintents/","text":"Gateway Intents \u00b6 Gateway Intents are Discord's way of giving the developers a option to choose, which information their bot needs and which they don't need. This helps reducing traffic and resource intense operations as your bot no longer needs to listen and look for any possible action, as the API simply won't send those when not needed. The Gateway Intents were introduced in version 6 of the Discord REST API and will be mandatory in version 7. This page covers some parts you may want to know about Gateway Intents and some common questions like \"Which one will I need for my bot?\" Usage in JDA \u00b6 Gateway Intents are implemented into JDA as their own enum called GatewayIntent and can be used when building/starting the bot. Enabling Intents \u00b6 You can use the JDABuilder#setEnabledIntents(GatewayIntent, GatewayIntent...) or DefaultShardManagerBuilder#sezEnabledIntents(GatewayIntent, GatewayIntent...) method to set the enabled Gateway Intents. This will automatically disable all not set Intents. Disabling Intents \u00b6 If you only want to disable a selected few Intents can you use JDA#setDisabledIntents(GatewayIntent, GatewayIntent...) or DefaultShardManagerBuilder#setDisabledIntents(GatewayIntent, GatewayIntent...) to do so. It is required to disable Prvileged Intents if you don't have them enabled in your developer-dashboard. Privileged Intents \u00b6 Important Bots that are on less than 100 Guilds won't require whitelisting. Bots which are on more than 100 Guilds and aren't whitelisted, only have access to 100 Guilds. Those privileged intents are currently available for all Bots without requirement of whitelisting. This may change in the future Discord has two Gateway Intents which are \"privileged\", meaning they require Discord to whitelist you, to access them. Those intents are GUILD_MEMBERS (Receive information about members) and GUILD_PRESENCES (Receive information about precense updates). Your bot will break when you try to access those without being whitelisted. You need to also set your ChunkingFilter to ChunkingFilter.NONE when GUILD_MEMBERS isn't used. Changes to DefaultShardManagerBuilder \u00b6 The DefaultShardManagerBuilder received some major changes with the introduction of Gateway Intents. The Constructors are now deprecated and it is recommendet to use DefaultShardManagerBuilder.create(String, GatewayIntent, GatewayIntent... instead. // Old method public static void main ( String [] args ) throws LoginException { new DefaultShardManagerBuilder ( args [ 0 ] ) // args[0] = token of bot . build (); } // New method public static void main ( String [] args ) throws LoginException { DefaultShardManagerBuilder . create ( args [ 0 ] , GatewayIntent . GUILD_MESSAGES , GUILD_MESSAGE_REACTIONS ) . build (); } Note that you can also use DefaultShardManagerBuilder.createDefault(String) to setup default Gateway Intents and settings. Recommendet Intents \u00b6 Here is a list of recommendet Intents that should be set. All bots \u00b6 For all bots is it recommendet to have GUILD_MESSAGES enabled, to receive messages on the Guilds (For command execution). If your bot also allows commands to be used through DM, is DIRECT_MESSAGES required. Music Bots \u00b6 GUILD_VOICE_STATES is required for tracking Voice state changes (i.e. Member joining/leaving a Voice chat), but also to connect to the voice chat yourself . Bots without this intent cannot join voice chats. Giveaway Bots \u00b6 If your Giveaway Bot is using Reactions for its Giveaways will it require the GUILD_MESSAGE_REACTIONS intent to listen for Reaction events (Adding/Removing reactions). Moderation Bots \u00b6 Bots which perform Moderation tasks like kicking or banning Members should have the GUILD_BANS intent to keep track of kicks/bans performed by other moderators/bots. Additionally if your bot also tracks invite creation/deletion as a moderation feature is GUILD_INVITES required.","title":"GatewayIntents"},{"location":"usage/gatewayintents/#gateway-intents","text":"Gateway Intents are Discord's way of giving the developers a option to choose, which information their bot needs and which they don't need. This helps reducing traffic and resource intense operations as your bot no longer needs to listen and look for any possible action, as the API simply won't send those when not needed. The Gateway Intents were introduced in version 6 of the Discord REST API and will be mandatory in version 7. This page covers some parts you may want to know about Gateway Intents and some common questions like \"Which one will I need for my bot?\"","title":"Gateway Intents"},{"location":"usage/gatewayintents/#usage-in-jda","text":"Gateway Intents are implemented into JDA as their own enum called GatewayIntent and can be used when building/starting the bot.","title":"Usage in JDA"},{"location":"usage/gatewayintents/#enabling-intents","text":"You can use the JDABuilder#setEnabledIntents(GatewayIntent, GatewayIntent...) or DefaultShardManagerBuilder#sezEnabledIntents(GatewayIntent, GatewayIntent...) method to set the enabled Gateway Intents. This will automatically disable all not set Intents.","title":"Enabling Intents"},{"location":"usage/gatewayintents/#disabling-intents","text":"If you only want to disable a selected few Intents can you use JDA#setDisabledIntents(GatewayIntent, GatewayIntent...) or DefaultShardManagerBuilder#setDisabledIntents(GatewayIntent, GatewayIntent...) to do so. It is required to disable Prvileged Intents if you don't have them enabled in your developer-dashboard.","title":"Disabling Intents"},{"location":"usage/gatewayintents/#privileged-intents","text":"Important Bots that are on less than 100 Guilds won't require whitelisting. Bots which are on more than 100 Guilds and aren't whitelisted, only have access to 100 Guilds. Those privileged intents are currently available for all Bots without requirement of whitelisting. This may change in the future Discord has two Gateway Intents which are \"privileged\", meaning they require Discord to whitelist you, to access them. Those intents are GUILD_MEMBERS (Receive information about members) and GUILD_PRESENCES (Receive information about precense updates). Your bot will break when you try to access those without being whitelisted. You need to also set your ChunkingFilter to ChunkingFilter.NONE when GUILD_MEMBERS isn't used.","title":"Privileged Intents"},{"location":"usage/gatewayintents/#changes-to-defaultshardmanagerbuilder","text":"The DefaultShardManagerBuilder received some major changes with the introduction of Gateway Intents. The Constructors are now deprecated and it is recommendet to use DefaultShardManagerBuilder.create(String, GatewayIntent, GatewayIntent... instead. // Old method public static void main ( String [] args ) throws LoginException { new DefaultShardManagerBuilder ( args [ 0 ] ) // args[0] = token of bot . build (); } // New method public static void main ( String [] args ) throws LoginException { DefaultShardManagerBuilder . create ( args [ 0 ] , GatewayIntent . GUILD_MESSAGES , GUILD_MESSAGE_REACTIONS ) . build (); } Note that you can also use DefaultShardManagerBuilder.createDefault(String) to setup default Gateway Intents and settings.","title":"Changes to DefaultShardManagerBuilder"},{"location":"usage/gatewayintents/#recommendet-intents","text":"Here is a list of recommendet Intents that should be set.","title":"Recommendet Intents"},{"location":"usage/gatewayintents/#all-bots","text":"For all bots is it recommendet to have GUILD_MESSAGES enabled, to receive messages on the Guilds (For command execution). If your bot also allows commands to be used through DM, is DIRECT_MESSAGES required.","title":"All bots"},{"location":"usage/gatewayintents/#music-bots","text":"GUILD_VOICE_STATES is required for tracking Voice state changes (i.e. Member joining/leaving a Voice chat), but also to connect to the voice chat yourself . Bots without this intent cannot join voice chats.","title":"Music Bots"},{"location":"usage/gatewayintents/#giveaway-bots","text":"If your Giveaway Bot is using Reactions for its Giveaways will it require the GUILD_MESSAGE_REACTIONS intent to listen for Reaction events (Adding/Removing reactions).","title":"Giveaway Bots"},{"location":"usage/gatewayintents/#moderation-bots","text":"Bots which perform Moderation tasks like kicking or banning Members should have the GUILD_BANS intent to keep track of kicks/bans performed by other moderators/bots. Additionally if your bot also tracks invite creation/deletion as a moderation feature is GUILD_INVITES required.","title":"Moderation Bots"},{"location":"usage/restaction/","text":"RestActions \u00b6 RestActions where introduced in JDA 3.0 and are since then a key part of the project. The RestAction can be seen as a terminal between the JDA user and the Discord REST API, handling the requests about what your bot wants to do and executing it. It allows you to specify how JDA should deal with their requests. That said, will you need to actually \"tell\" the RestAction to do something . It is recommendet to always check if something in JDA is returning a RestAction. If it does, then you have to execute it using one of the below listed operations: queue(), queue(Consumer) or queue(Consumer, Consumer) These operations are run asynchronous, meaning they won't execute in the same Thread. This means you can't use procedural logic when using queue() , unless you use the callback Consumer (Click the link for more info). complete() Calling this operation will block the current Thread until the request has finished and returns the response type. submit() Provides request future to cancel tasks later and avoid callback hell. xAfter(...) queueAfter() , completeAfter() and submitAfter() provide similar functionalities as their normal counterparts, but with the ability to delay the execution. Note We recommend using queue() or submit() when possible as blocking the current Thread could cause unwanted side-effects. Since JDA 4.1.1 can you use additional methods to prevent a so called \"Callback hell\" with queue() . - map Convert the result of the RestAction to a different value. - flatMap Chain another RestAction on the result. - delay Delay the element of the previous step. AuditLog Reasons \u00b6 Some operations return a special RestAction implementation called AuditableRestAction . This extension allows to set a reason field for that action. These reasons are only available for accounts of AccountType.BOT but will silently be ignored for any non-bot accounts. However, any account type can use reasons on kicks and bans with the special overloads provided that allows setting a reason. Example : public class ModUtil { public static void deleteMessage ( Message message , String reason ){ message . delete (). reason ( reason ). queue (); } public static void banMember ( Guild guild , User user , String reason ){ guild . ban ( user , 7 , reason ). queue (); } } Asynchronous \u00b6 queue() \u00b6 The most common way for executing a RestAction is to simply call queue() : public void sendMessage ( MessageChannel channel , String message ){ channel . sendMessage ( message ). queue (); } Note that this RestAction might be finished before other RestActions which used queue. For example: Your bot opens a DM with a user and then sends a message in said DM. Due to the nature of async methods can it happen that sending the message is finished first, causing an error, when the channel isn't available. You can use one of the below mentioned variants of queue for fixing this, or use the flatMap option added in JDA 4.1.1! queue(Consumer) \u00b6 queue(Consumer<T>) allows you to execute a RestAction using queue and then performing additional actions once this has finished. Example: Sending a DM \u00b6 You may want to send a DM from your bot to a user to f.e. send the command help. Using queue is the recommendet way here, but can cause unwanted side effects as sending the DM could happen before the DM was even opened. This is where the success callback (Or Success Consumer ) comes into play! Let's first make a little example with our DM thing: public void sendDM ( User user , String message ){ user . openPrivateChannel (). queue ( new Consumer < PrivateChannel > (){ // queue returns a PrivateChannel object @Override public void accept ( PrivateChannel channel ){ channel . sendMessage ( message ). queue (); } }); } \"But that looks really ugly!\" will you now say, right? Don't worry, there is a solution for this. Since JDA requires you to use Java 8, can you use something quite useful: Lambda expressions! public void sendDM ( User user , String message ){ // We call the callback \"channel\" here and use it as a reference. Consumer < PrivateChannel > callback = ( channel ) -> channel . sendMessage ( message ). queue (); user . openPrivateChannel (). queue ( callback ); // callback will execute the above Consumer. } But wait! You can even simplify it more: public void sendDM ( User user , String message ){ // We set \"channel\" as reference, which is an instance of Consumer<PrivateChannel> user . openPrivateChannel (). queue (( channel ) -> channel . sendMessage ( message )); } queue(Consumer, Consumer) \u00b6 \"But what if the user doesn't allow DMs?\" For that does queue(Consumer<T>, Consumer<Throwable>) exist! The first Consumer is used on a successfull action, while the second one is used on a failed one. Note, that in this case, you have to use it for the queue of sending the message, as opening a Private channel rarely fails. Note With JDA 4.1.1 where map 's and flatMap 's added, which improve handling cases like the above example with sending a DM a lot. Blocking \u00b6 complete() \u00b6 The complete() method is simply for convenience as it does nothing more than calling queue() and blocking the Thread. It is highly recommendet to use queue() or submit() if you don't use return values or need to wait for an action to finish before others. Cancelable \u00b6 submit() \u00b6 Sometimes do you want to cancel a request before it gets executed, to prevent errors. This can be quite challenging when using queue() or complete() . In submit() does JDA provide a CompletableFuture (aka promise) which allows you to cancel it when not needed. If you don't need a CompletableFuture you may want to use queue() instead! Example: Change channel settings \u00b6 // With just using queue() public void setTestChannel ( TextChannel channel ){ channel . getManager (). setName ( \"test-channel\" ). queue (( v ) -> channel . sendMessage ( \"Update channel\" ). queue (( m ) -> m . delete (). queueAfter ( 30 , TimeUnit . SECONDS , ( t ) -> logger . info ( \"Deleted response in \" + channel . getName ()); ) ) ) } // Using submit() instead public void setTestChannel ( TextChannel channel ){ channel . getManager (). setName ( \"test-channel\" ). submit () . thenCompose (( v ) -> channel . sendMessage ( \"Update Channel\" ). submit ()) . thenCompose (( m ) -> m . delete (). submitAfter ( 30 , TimeUnit . SECONDS )) . thenCompose (( t ) -> logger . info ( \"Deleted response in \" + channel . getName ())) . whenComplete (( s , error ) // This is called on termination (success/failure) // If the result is successfull is error null if ( error != null ) error . printStackTrace (); ) } Note With JDA 4.1.1 can you now use RestAction#flatMap to achieve similar results with methods like queue() Planning \u00b6 The xAfter() are also known as Planned Execution as they use a ScheduledExecutorService to schedule calls to either complete() or queue() . Info With the exception of completeAfter() can you provide a own ScheduledExecutorService as the last argument to any of the methods. queueAfter(long, TimeUnit) \u00b6 Sends a delayed queue() action. queueAfter(long, TimeUnit, Consumer) \u00b6 Sends a delayed queue(Consumer<T>) action. queueAfter(long, TimeUnit, Consumer, Consumer) \u00b6 Sends a delayed queue(Consumer<T>, Consumer<Throwable> action. completeAfter(long, TimeUnit) \u00b6 Sends a delayed complete() action. Note that this is the only xAfter() method, that doesn't provide an option to use a own ScheduledExecutorService. submitAfter(long, TimeUnit) \u00b6 Creates a DelayedCompletableFuture<T> which will hold the response type as its generic value. This means that using get() on the returned Future will cause the curren thread to block and await the execution of the RestAction and receive the response type.","title":"RestAction"},{"location":"usage/restaction/#restactions","text":"RestActions where introduced in JDA 3.0 and are since then a key part of the project. The RestAction can be seen as a terminal between the JDA user and the Discord REST API, handling the requests about what your bot wants to do and executing it. It allows you to specify how JDA should deal with their requests. That said, will you need to actually \"tell\" the RestAction to do something . It is recommendet to always check if something in JDA is returning a RestAction. If it does, then you have to execute it using one of the below listed operations: queue(), queue(Consumer) or queue(Consumer, Consumer) These operations are run asynchronous, meaning they won't execute in the same Thread. This means you can't use procedural logic when using queue() , unless you use the callback Consumer (Click the link for more info). complete() Calling this operation will block the current Thread until the request has finished and returns the response type. submit() Provides request future to cancel tasks later and avoid callback hell. xAfter(...) queueAfter() , completeAfter() and submitAfter() provide similar functionalities as their normal counterparts, but with the ability to delay the execution. Note We recommend using queue() or submit() when possible as blocking the current Thread could cause unwanted side-effects. Since JDA 4.1.1 can you use additional methods to prevent a so called \"Callback hell\" with queue() . - map Convert the result of the RestAction to a different value. - flatMap Chain another RestAction on the result. - delay Delay the element of the previous step.","title":"RestActions"},{"location":"usage/restaction/#auditlog-reasons","text":"Some operations return a special RestAction implementation called AuditableRestAction . This extension allows to set a reason field for that action. These reasons are only available for accounts of AccountType.BOT but will silently be ignored for any non-bot accounts. However, any account type can use reasons on kicks and bans with the special overloads provided that allows setting a reason. Example : public class ModUtil { public static void deleteMessage ( Message message , String reason ){ message . delete (). reason ( reason ). queue (); } public static void banMember ( Guild guild , User user , String reason ){ guild . ban ( user , 7 , reason ). queue (); } }","title":"AuditLog Reasons"},{"location":"usage/restaction/#asynchronous","text":"","title":"Asynchronous"},{"location":"usage/restaction/#queue","text":"The most common way for executing a RestAction is to simply call queue() : public void sendMessage ( MessageChannel channel , String message ){ channel . sendMessage ( message ). queue (); } Note that this RestAction might be finished before other RestActions which used queue. For example: Your bot opens a DM with a user and then sends a message in said DM. Due to the nature of async methods can it happen that sending the message is finished first, causing an error, when the channel isn't available. You can use one of the below mentioned variants of queue for fixing this, or use the flatMap option added in JDA 4.1.1!","title":"queue()"},{"location":"usage/restaction/#queueconsumer","text":"queue(Consumer<T>) allows you to execute a RestAction using queue and then performing additional actions once this has finished.","title":"queue(Consumer)"},{"location":"usage/restaction/#example-sending-a-dm","text":"You may want to send a DM from your bot to a user to f.e. send the command help. Using queue is the recommendet way here, but can cause unwanted side effects as sending the DM could happen before the DM was even opened. This is where the success callback (Or Success Consumer ) comes into play! Let's first make a little example with our DM thing: public void sendDM ( User user , String message ){ user . openPrivateChannel (). queue ( new Consumer < PrivateChannel > (){ // queue returns a PrivateChannel object @Override public void accept ( PrivateChannel channel ){ channel . sendMessage ( message ). queue (); } }); } \"But that looks really ugly!\" will you now say, right? Don't worry, there is a solution for this. Since JDA requires you to use Java 8, can you use something quite useful: Lambda expressions! public void sendDM ( User user , String message ){ // We call the callback \"channel\" here and use it as a reference. Consumer < PrivateChannel > callback = ( channel ) -> channel . sendMessage ( message ). queue (); user . openPrivateChannel (). queue ( callback ); // callback will execute the above Consumer. } But wait! You can even simplify it more: public void sendDM ( User user , String message ){ // We set \"channel\" as reference, which is an instance of Consumer<PrivateChannel> user . openPrivateChannel (). queue (( channel ) -> channel . sendMessage ( message )); }","title":"Example: Sending a DM"},{"location":"usage/restaction/#queueconsumer-consumer","text":"\"But what if the user doesn't allow DMs?\" For that does queue(Consumer<T>, Consumer<Throwable>) exist! The first Consumer is used on a successfull action, while the second one is used on a failed one. Note, that in this case, you have to use it for the queue of sending the message, as opening a Private channel rarely fails. Note With JDA 4.1.1 where map 's and flatMap 's added, which improve handling cases like the above example with sending a DM a lot.","title":"queue(Consumer, Consumer)"},{"location":"usage/restaction/#blocking","text":"","title":"Blocking"},{"location":"usage/restaction/#complete","text":"The complete() method is simply for convenience as it does nothing more than calling queue() and blocking the Thread. It is highly recommendet to use queue() or submit() if you don't use return values or need to wait for an action to finish before others.","title":"complete()"},{"location":"usage/restaction/#cancelable","text":"","title":"Cancelable"},{"location":"usage/restaction/#submit","text":"Sometimes do you want to cancel a request before it gets executed, to prevent errors. This can be quite challenging when using queue() or complete() . In submit() does JDA provide a CompletableFuture (aka promise) which allows you to cancel it when not needed. If you don't need a CompletableFuture you may want to use queue() instead!","title":"submit()"},{"location":"usage/restaction/#example-change-channel-settings","text":"// With just using queue() public void setTestChannel ( TextChannel channel ){ channel . getManager (). setName ( \"test-channel\" ). queue (( v ) -> channel . sendMessage ( \"Update channel\" ). queue (( m ) -> m . delete (). queueAfter ( 30 , TimeUnit . SECONDS , ( t ) -> logger . info ( \"Deleted response in \" + channel . getName ()); ) ) ) } // Using submit() instead public void setTestChannel ( TextChannel channel ){ channel . getManager (). setName ( \"test-channel\" ). submit () . thenCompose (( v ) -> channel . sendMessage ( \"Update Channel\" ). submit ()) . thenCompose (( m ) -> m . delete (). submitAfter ( 30 , TimeUnit . SECONDS )) . thenCompose (( t ) -> logger . info ( \"Deleted response in \" + channel . getName ())) . whenComplete (( s , error ) // This is called on termination (success/failure) // If the result is successfull is error null if ( error != null ) error . printStackTrace (); ) } Note With JDA 4.1.1 can you now use RestAction#flatMap to achieve similar results with methods like queue()","title":"Example: Change channel settings"},{"location":"usage/restaction/#planning","text":"The xAfter() are also known as Planned Execution as they use a ScheduledExecutorService to schedule calls to either complete() or queue() . Info With the exception of completeAfter() can you provide a own ScheduledExecutorService as the last argument to any of the methods.","title":"Planning"},{"location":"usage/restaction/#queueafterlong-timeunit","text":"Sends a delayed queue() action.","title":"queueAfter(long, TimeUnit)"},{"location":"usage/restaction/#queueafterlong-timeunit-consumer","text":"Sends a delayed queue(Consumer<T>) action.","title":"queueAfter(long, TimeUnit, Consumer)"},{"location":"usage/restaction/#queueafterlong-timeunit-consumer-consumer","text":"Sends a delayed queue(Consumer<T>, Consumer<Throwable> action.","title":"queueAfter(long, TimeUnit, Consumer, Consumer)"},{"location":"usage/restaction/#completeafterlong-timeunit","text":"Sends a delayed complete() action. Note that this is the only xAfter() method, that doesn't provide an option to use a own ScheduledExecutorService.","title":"completeAfter(long, TimeUnit)"},{"location":"usage/restaction/#submitafterlong-timeunit","text":"Creates a DelayedCompletableFuture<T> which will hold the response type as its generic value. This means that using get() on the returned Future will cause the curren thread to block and await the execution of the RestAction and receive the response type.","title":"submitAfter(long, TimeUnit)"}]}